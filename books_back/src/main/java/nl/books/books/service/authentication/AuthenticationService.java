package nl.books.books.service.authentication;import nl.books.books.exceptions.TokenExcpetion;import nl.books.books.exceptions.UserWrongCredentialsException;import nl.books.books.model.Role;import nl.books.books.model.User;import nl.books.books.model.dto.AuthResponseDTO;import nl.books.books.model.dto.LoginDTO;import nl.books.books.model.dto.RegistrationDTO;import nl.books.books.repository.RoleRepository;import nl.books.books.repository.UserRepository;import nl.books.books.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.bind.annotation.ExceptionHandler;import java.security.NoSuchAlgorithmException;import java.util.*;import java.util.regex.Pattern;@Service@Transactionalpublic class AuthenticationService {    @Autowired    private RoleRepository roleRepository;    @Autowired    private UserRepository userRepository;    @Autowired    private PasswordEncoder passwordEncoder;    @Autowired    private TokenService tokenService;    @Autowired    private AuthenticationManager authenticationManager;    @Autowired    private CookieService cookieService;    @Autowired    private UserService userService;    /**     * Registers a new user.     *     * @param registrationDTO The registration details     * @return The registered user     */    public User registerUser(RegistrationDTO registrationDTO) {        validateRegistrationDetails(registrationDTO);        // Encode password        String encodedPassword = passwordEncoder.encode(registrationDTO.getPassword());        // Get or create the default role        Role userRole = roleRepository.findByAuthority("USER")                .orElseGet(() -> {                    Role newUserRole = new Role();                    newUserRole.setAuthority("USER");                    return roleRepository.save(newUserRole);                });        Set<Role> roles = new HashSet<>();        roles.add(userRole);        // Create and save the user        User user = new User();        user.setUsername(registrationDTO.getUsername());        user.setPassword(encodedPassword);        user.setEmail(registrationDTO.getEmail());        user.setImagePath(registrationDTO.getImagePath());        user.setAuthorities(roles);        try {            return userRepository.save(user);        } catch (Exception e) {            throw new UserWrongCredentialsException("Username or Email is already registered.");        }    }    /**     * Logs in a user and generates authentication tokens.     *     * @param loginDTO The login details     * @param ipAddr   The IP address of the client     * @return AuthResponseDTO with authentication tokens     */    public ResponseEntity<AuthResponseDTO> loginUser(LoginDTO loginDTO, String ipAddr) throws NoSuchAlgorithmException {        Optional<User> userOptional = userRepository.findByUsername(loginDTO.getUsername());        if (userOptional.isEmpty()) {            throw new UserWrongCredentialsException("Invalid username.");        }        User user = userOptional.get();        // Authenticate user        authenticationManager.authenticate(                new UsernamePasswordAuthenticationToken(user.getUsername(), loginDTO.getPassword())        );        // Create an Authentication object        Authentication authentication = new UsernamePasswordAuthenticationToken(                user.getUsername(),                null, // No credentials needed as we're creating this manually                user.getAuthorities()        );// Pass the Authentication object to the generateJwt method        String jwt = tokenService.generateJwt(authentication, user.getId());        String token = cookieService.generateCookies(user.getUsername(), ipAddr);        AuthResponseDTO response = new AuthResponseDTO(                user.getUsername(),                user.getEmail(),                jwt,                token        );        return ResponseEntity.ok(response);    }    public ResponseEntity<Boolean> validateJwt(String jwt) {        if (jwt.isEmpty()) {            throw new TokenExcpetion("Invalid token.");        }        Optional<User> userOptional = userService.getUserFromJwt(jwt);        if (userOptional.isEmpty()) {            throw new TokenExcpetion("Invalid token.");        }        return ResponseEntity.ok(true);    }    /**     * Validates registration details for email and password.     *     * @param registrationDTO The registration details     */    private void validateRegistrationDetails(RegistrationDTO registrationDTO) {        String emailRegex =                "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@" +                        "(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$";        String passwordRegex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@#$%^&+=!]).{8,}$";        if (!Pattern.matches(emailRegex, registrationDTO.getEmail())) {            throw new UserWrongCredentialsException("Invalid email.");        }        if (!Pattern.matches(passwordRegex, registrationDTO.getPassword())) {            throw new UserWrongCredentialsException("Password is too weak. It must contain uppercase, lowercase, digit, and a special character.");        }    }    @ExceptionHandler({UserWrongCredentialsException.class, TokenExcpetion.class})    public ResponseEntity<Map<String, String>> handleUserErrorException(RuntimeException e) {        Map<String, String> error = new HashMap<>();        error.put("error", e.getMessage());        return new ResponseEntity<>(error, HttpStatus.FORBIDDEN);    }}